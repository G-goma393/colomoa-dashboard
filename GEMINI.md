# はじめに
こんにちは、見てくれてありがとう。このファイルはAIエージェント向けにcolomoa-dashboardプロジェクトのアーキテクチャや目的、進捗といった全体像を書き留めておく文書ファイルです。  
## 自己紹介
gomaといいます。趣味はゲームと個人開発です。私の開発経験はその場その時作りたいものを作る...です。そのため時にはESP32とセンサ基盤で家族や友人にいたずらしたりRaspiクラスターを作り出してはVOICEVOX coreとChatGPT APIでチャットボットを作ったりMinecraftのModサーバーを運営管理したりそれ用のModpackを作ったりFPSクランのホームページを作成したり学校のオンライン掲示板を使いやすくしたDiscord Botを開発したりと...etc、一貫性が微塵もありません。最近はソフトウェア開発とWeb制作に興味を持っていてyt-dlpのGUIツールをTKinterで作ったりファイル操作の自動化のためのマルチプラットフォーム対応のスタンドアロンアプリをJavaFXで作ったりしています。colomoa-dashboardはWeb制作関連です。そんな私のよく使う開発言語は習熟度順にPython/Javascript/HTML/CSS/Java/Arduino/C/C++/。
### 開発環境
デスクトップとのノートパソコンの２台での開発がメイン。どちらもWindows11 homeとArch LinuxのCachyOSと別々の物理ディスクでデュアルブートしてる。  
Shellにはfish 4.2.1。デスクトップにはKDE Plasma 6.5.3。よく分かってないけどWMにはKWin(Wayland)。パッケージマネージャにはpacmanとyay。ここまではデスクトップとノートパソコンどちらも同じ。  

# 目的
> Q.んで、何をするの？  
A.イカしたダッシュボードを作る

タスク管理やナレッジベースにNotionを使ってたけれど、大規模傷害やオフライン環境に弱いこと、拘り抜いたダッシュボードの容量が肥大化して高速な通信環境でないと中々開く気になれないということ。そして何よりも大切なノートが手元にないという不安感からObsidianに移行しました。Notionの不満点は解消されましたが私の要求をObsidianがすべて満たしている訳ではありません。例えば別端末間の同期問題やコミュニティプラグインの不具合、何よりもイカしたダッシュボードがMarkdownでは実現できません。いくつかの私の要求はプラグインが満たしてくれますが私が追い求める理想のダッシュボードプラグインは見つかることはありません。しかし私には「ないものは作る」の精神が宿っています。ということで.....
**ObsidianプラグインとGoogleAppsScriptでイカしたダッシュボードを作る**  
これが今回のメイン目標です。
# 要件定義
> ObsidianプラグインとGoogleAppsScriptでイカしたダッシュボードを作る

## 要件
- オフラインでもほとんどの機能は動作すること
- Arch Linux, Windows11に対応していること（Android, iOSなど携帯端末は無視
- ダッシュボードのすべての機能をシングルページで補う
- Obsidianを起動して最初の画面にダッシュボードを設定できること
- リマインド通知が可能
## 機能詳細
colomoa-dashboardの機能の全容です。  
**ToDoリスト機能**
メインに完了済みかどうかのチェックボックスとタスク名のみを表示させたシンプルなToDoリスト。
サブに自由に追加・削除ができる[未着手|進行中|完了]に分けて管理する方式のToDoリストの合計２種を一つの画面に集約。
リマインド通知が設定可能で設定にはGASでデプロイしたWebアプリとDiscord WebhookURLが追加する必要がある。
タスクを追加/変更する際は専用のポップアップが開きそこで行う
**RSSリーダー機能**
RSSフィードはユーザが自由に追加変更が可能でRSSフィードは垂直タブバーで１つずつ管理する形式。将来的にはAIのAPIと連携して記事の要約機能を追加したい。
**システムモニター機能**
CPU使用率・Memory使用量・GPU使用率・Disk使用率を表示....できるのか？
**天気API連携**
ユーザが設定した座標の一日天気を表示
**Google Drive Syncプラグイン連携**
ObsidianリダイレクトURIで動作する機能の一つで対応するボタンを押すことでpushやpullコマンドを実行する
**その他**
ローカルに置いた画像の表示機能と機能の設定をプロファイルに登録できる。
将来的にはプレイリストを再生する機能を追加したりGeminiCLIを動かせるようにしたい。

## 使用技術（想定）
フロントエンド：React|TypeScript|HTML/CSS  
バックエンド：GoogleAppsScript
ObsidianプラグインにWeb制作とGoogleAppsScriptの３つの分野が入り混じった壮大なシステム開発となる。
# 進捗計画
## フェーズ1：最小構成で概念検証
最低限の機能を実装し、最小構成で概念検証を行う。
- [ ] 環境構築　　：ObsidianプラグインでHelloWorldする
- [ ] 環境構築　　：hello Swiper.jsで作成したSPAをObsidianで表示する
- [ ] コンテンツ：URIでObsidianへリダイレクトしてみる
- [ ] コンテンツ：RSSフィードを取得、ページに表示してみる（外部APIは省く）。
  
## フェーズ2：フロントエンドの開発
viteのローカル開発サーバー(npm run dev)でまずはUIを完成させていく。UIデザインは3DCubeを土台に立方体の面にUI部品を配置していく。
### フェーズ2.1: hello Swiper.js
Swiper.jsのドキュメントを片手にTypeScript+Reactでシンプルなページを作り土台を用意する。
【↓】Getting Started
https://swiperjs.com/get-started
【↓】API Doc
https://swiperjs.com/swiper-api
- [X] TypeScriptでhellowold
- [X] ↑にReactで装飾する
- [X] Swiper.jsを加え先程の機能を実装する
### フェーズ2.2 Swiper.js + Obsidianプラグイン
フェーズ1で作成した雛形を参考にフロントエンドを完成させObsdiainプラグインとして実装する。ちなみにこの領域に関して私は驚くほど無知なので手探りの状態から始める。
- [ ] 一面：ToDoリスト｜中央列
- [ ] 一面：各種設定用ポップアップ
- [ ] 一面：天気API連携｜右列
- [ ] 一面：Google Drive Syncプラグイン連携｜中央列右上
- [ ] 一面：画像表示機能｜左列・中央の背景・右列に二枚
- [ ] 一面：システムモニター機能｜右列右上
- [ ] 二面：RSSリーダー
- [ ] 三面：空白｜将来的に機能を追加するためのスペース
--- サブクエスト ---
- [ ] 【できれば】Homepageプラグイン依存からの脱却

## フェーズ３：バックエンド開発と統合
このフェーズではバックエンドの完成を目標にフェーズ２で作成したUI部品と融合させる。システムの中核であり工数がかなり多い。
- [ ] タスクリストとGASを結びつける
- [ ] GASとDiscordWebhookを結びつける
- [ ] 一面：ToDoリスト機能｜中央列
- [ ] 一面：各種設定用ポップアップ
- [ ] 一面：天気API連携｜右列
- [ ] 一面：Google Drive Syncプラグイン連携｜中央列右上
- [ ] 一面：画像表示機能｜左列・中央の背景・右列に二枚
- [ ] 一面：システムモニター機能｜右列右上
- [ ] 二面：RSSリーダー機能  

**用語の定義**
タスク・・・やること。１つ付箋のようなもの
タスクリスト・・・タスクをまとめたもの、基本的にローカルを指す。
DB・・・スプレットシートにまとめられたタスクリストのこと
Push・・・ObsidianVaultのGoogle Drive Syncを使ったアップロードのこと
Pull・・・ObsidianVaultのGoogle Drive Syncを使ったダウンロードのこと

**前提**
タスクリストとDBは非同期であるべき
オフライン環境でも使用できるようにあるべき

### システムの流れ
[OBS]Obsidianを起動
[OBS]タスクリストを送信｜doPost
[GAS]タスクリストとDBを比較して同期処理
[OBS]タスクリストをインポート｜doPost 
[OBS]タスクが追加/変更されたことが確定する｜doPost
[GAS]非同期でDBに書き込む
[GAS]リマインド通知日時が設定されている場合、時間主導型トリガーを設置する
[OBS]リマインド通知を設定したタスクが完了済みになった場合｜doPost
[GAS]時間主導型トリガーを取り下げる
--- リマインド通知の時刻になったら ---
[GAS]リマインド通知処理を実行｜時間主導型トリガー
※時間主導型トリガーは特定日時のもが好ましい

### DBとタスクリストに違いがある場合分け
**case1 : オフライン環境で追加・変更されたタスクリスト**
状態：オフラインからオンラインに復帰時を想定、DBが遅れて端末が最新
対応：DBに対して
    追加されたタスクに関してはDBに追加する
    変更されたタスクに関しては最終更新日時を参照して新しい方を優先する

**case2 : 端末を切り替えた時（端末AでPushして端末BでPull）**
対応：違いがあってはならない。Vaultの同期にタスクリストが乗っかってるから存在し得ないはず。
懸念点：Vaultの同期の前にタスクリストを同期してしまう可能性

**case3 : 端末を切り替えた時（端末AでPushせずに端末BでPull）**
状態：DBが最新で端末Bが遅れ
対応：DBとローカルのタスクリストを比較して
    追加/変更されたものがDBにあればローカルにインポート
    もしDBで「削除済み」なら、ローカルのファイルも削除
    DBにないタスクがローカルにある場合はDBに追加する
    名前は同じだけど状態が違うものがローカルにある場合は最終更新日時を参照して新しい方を優先する
    
**case4 : 同期ズレ（タスクを追加/変更してすぐに同期した）**
状態：非同期処理中に同期した
対応：同期する前に先程反映されたかどうか確認する

**case5 : DBの直接変更**
状態：ユーザが直接スプレットシートを編集する
対応：原則編集しないことにする。万が一編集されたとしてもcase3の対応が吸ってくれる

### データ構造のスキーマ
`{UUID}{タスク名}{完了フラグ(bool)}{通知日時(UnixTime)}{更新日時(UnixTime)}{通知済みフラグ(bool)}{削除フラグ}`
`{uuid}{title}{isDone}{dueTime}{updatedAt}{isNotified}{isDeleted}`  
項目名,変数名(例),型,備考  
UUID,uuid,String,主キー。これを使って検索・比較する。  
タスク名,title,String,  
完了フラグ,isDone,Boolean,TRUE / FALSE  
通知日時,dueTime,Number,UNIX Time (ミリ秒)。通知不要な場合は空欄or0  
更新日時,updatedAt,Number,UNIX Time (ミリ秒)。同期の判断基準。  
通知済フラグ,isNotified,Boolean,TRUE なら通知処理をスキップ。  
削除フラグ,isDeleted,Boolean,論理削除用。
